
## Directory / dev and the files that compose it
As mentioned during the presentation of the file system the / dev directory contains the file definition of the devices available on the system. So if we list the files contained in the directory we will find that there are many, a small explanation is needed to understand their meaning.


There are 2 types of device:

* blocks: block devices transmit or receive information in the form of byte packets, of a fixed size: this is for example the case of mass storage media (diskettes, hard disks ...) .
* Characters: Character devices have the characteristic of transmitting and receiving information byte by byte: this is for example the case of serial or parallel ports, modems, etc.


To know the type of the device use the command ls -l, the first character gives us this information, C for character and B for block. Here is an example for the console device and the sata hard drive:


### Example display of device AND block device characters

```
user@hostname:~$ ls -l /dev/sda /dev/sda1 /dev/console  
crw------- 1 root root 5, 1 Jan 27 12:16 /dev/console
brw-rw---- 1 root disk 8, 0 Jan 27 12:16 /dev/sda
brw-rw---- 1 root disk 8, 1 Jan 27 12:16 /dev/sda1
``` 

Here is an explanatory table of names and their roles:


Table 2.1: Some Special Files and Associated Devices


| <b><u>File</u></b> | <b><u>Major</u></b> | <b><u>Minor</u></b> | <b><u>B/C</u></b> | <b><u>Peripheral</u></b> |
| :---         | :---         | :---         | :---         | :---         |
| :small_orange_diamond: [/dev/mem]| 1 | 1 | c | direct access to the main memory |
| :small_orange_diamond: [/dev/fd0]| 2 | 0 | b | first floppy drive |
| :small_orange_diamond: [/dev/hdas]| 3 | 0 | b | master disk on the first IDE port |
| :small_orange_diamond: [/dev/hda2]| 3 | 2 | b | second primary partition on this disk |
| :small_orange_diamond: [/dev/hdb]| 3 | 64| b | slave disk on the first IDE port |
| :small_orange_diamond: [/dev/hdb5]| 3 | 69 | b | first logical partition on this disk |
| :small_orange_diamond: [/dev/tty1]| 4 | 1 | c | first virtual console |
| :small_orange_diamond: [/dev/lp0]| 6 | 2 | c | third parallel port (printer) |
| :small_orange_diamond: [/dev/sda]| 8 | 0 | b | first hard drive SCSI / SATA / USB drive, ... |
| :small_orange_diamond: [/dev/sda3]| 8 | 3 | b | third partition on this disk |
| :small_orange_diamond: [/dev/sdb]| 8 | 16 | b | second hard drive SCSI / SATA / USB drive, ... |
| :small_orange_diamond: [/dev/psaux]| 10 | 1 | c | PS / 2 port (mouse) |
| :small_orange_diamond: [/dev/bus/usb/001]| 11 | 0 | c | First USB Device |
| :small_orange_diamond: [/dev/scd0]| 11 | 0 | b | first SCSI CD-ROM |
| :small_orange_diamond: [/dev/video0]| 81  | 0 | c | Video acquisition |


and so on ... the complete list would occupy several pages!


https://www.kernel.org/doc/Documentation/devices.txt


There is also a pseudo-device, which exists only virtually but offers real functionality:
* /dev/zero generate zeros
* /dev/random generates randomness 
* /dev/null is a black hole byte, and used especially to get rid of files and displays
* /dev/loop0 allows you to create fake block (storage) devices from files created with the dd command 


The name of the file is independent of the driver or used hardware are generic names, attention this is not the case for all the unix, FreeBSD for example names the devices according to the driver.


Now that we are able to identify devices by name, we will see how the system works to communicate with them. If we take the case of the first SATA hard disk on the system, / dev / sda, if I list the partitions on the disk I will use the fdisk command, like this:


### example fdick, list partition.

```
user@hostname:~$ sudo fdisk -l /dev/sda 
Disk /dev/sda: 60.0 GB, 60011642880 bytes
255 heads, 63 sectors/track, 7296 cylinders, total 117210240 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0xeede9d79
 
   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048    58593279    29295616   83  Linux
/dev/sda2        58595326   117209087    29306881    5  Extended
/dev/sda5        58595328    64475135     2939904   82  Linux swap / Solaris
/dev/sda6        64477184   117209087    26365952   83  Linux
```

I use sudo to have permission to read the device.


## Major and minor
The file / dev / sda is a special file it is not enough to create an empty file in / dev with the right name for this function, it is necessary that the file is the good properties! It is important to define the correct type block or character, moreover it is necessary to define a major value (major) and minor (minor). These 2 values in combination with the type identify the device with which we want to interact. All communication with the hardware is done by the kernel, the latter keeps a table that allows it to do the correspondence with device.


Here is an example for sata hard drives:


| <b><u>Major</u></b> | <b><u>Minor</u></b> | <b><u>Device</u></b> | <b><u>Description</u></b> | 
| :---         | :---         | :---         | :---         | 
| :small_orange_diamond: [8]| 0 | /dev/sda  | First hard drive as a whole | 
| :small_orange_diamond: [8]| 1 | /dev/sda1  | The first partition of the First Hard Disk | 
| :small_orange_diamond: [8]| 2 | /dev/sda2  | The second partition of the First Hard Disk | 
| :small_orange_diamond: [8]| 16 | /dev/sdb  | Second hard drive as a whole | 
| :small_orange_diamond: [8]| 0 | /dev/sdb1  | First Partition Second Hard Disk | 


 

So Major 8 represents the devices on the SCSI BUS, SATA, ... the minor represents the detail with which we interact!


What is the process of creating these files? Because if I connect a USB key, the system will create the files / dev / sdb and / dev / sdb1, / dev / sdb2, .... The system automatically increments / dev / sda to take the next available hence / dev / sdb.


This is beautiful and again thank you for having upgraded the system, thanks to udev, for cons I would like to provide the information without the automatic system. Because under the hood there is a process.


The udev system uses the / bin / mknod command to create the files contained in / dev, here is an example:

### Exemple utilisation mknod

``` 
# device creation / dev / can
#  type   : block
#  majeur :  42
#  mineur :   0
$ mknod /dev/bidon b 42 0
 
 
# Documentation of the kernel.
# 42 block       Demo/sample use                                                                                                                                                           
#
#                This number is intended for use in sample code, as
#                well as a general "example" device number.  It
#                should never be used for a device driver that is being
#                distributed; either obtain an official number or use
#                the local/experimental range.  The sudden addition or
#                removal of a driver with this number should not cause
#                ill effects to the system (bugs excepted.)
``` 
 
Here we realize creation in / dev however this could be anywhere. This is INFORMATIVE, because if on a modern system you are obliged to perform this operation it means that there is REALLY a problem somewhere. I doubt that this operation corrects the problem, because the automation of the device creation process works very well and this hot. However, I find it interesting to know more about the file creation process.


## list devices
It's fine to know where the files will be located to communicate with the devices, but if I do not see the file on my device how can I list them ?! So we will see, how to have the list of devices in the system, we will take the opportunity to see the association of "driver / driver" that manages the hardware.

## List PCI devices
The lspci command allows us to list the PCI cards or the integrated devices, it is possible that a card is inserted in the system but that the operating system is not able to communicate with, in this case it would be listed, but there will be the word unknow of present. Here is an example of the lspci command:

### example lspci

```
$ lspci 
00:00.0 Host bridge: Intel Corporation Mobile 945GM/PM/GMS, 943/940GML and 945GT Express Memory Controller Hub (rev 03)
00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS, 943/940GML Express Integrated Graphics Controller (rev 03)
00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/GME, 943/940GML Express Integrated Graphics Controller (rev 03)
00:1b.0 Audio device: Intel Corporation NM10/ICH7 Family High Definition Audio Controller (rev 01)
00:1c.0 PCI bridge: Intel Corporation NM10/ICH7 Family PCI Express Port 1 (rev 01)
00:1c.1 PCI bridge: Intel Corporation NM10/ICH7 Family PCI Express Port 2 (rev 01)
00:1c.2 PCI bridge: Intel Corporation NM10/ICH7 Family PCI Express Port 3 (rev 01)
00:1d.0 USB controller: Intel Corporation NM10/ICH7 Family USB UHCI Controller #1 (rev 01)
00:1d.1 USB controller: Intel Corporation NM10/ICH7 Family USB UHCI Controller #2 (rev 01)
00:1d.2 USB controller: Intel Corporation NM10/ICH7 Family USB UHCI Controller #3 (rev 01)
00:1d.3 USB controller: Intel Corporation NM10/ICH7 Family USB UHCI Controller #4 (rev 01)
00:1d.7 USB controller: Intel Corporation NM10/ICH7 Family USB2 EHCI Controller (rev 01)
00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev e1)
00:1f.0 ISA bridge: Intel Corporation 82801GBM (ICH7-M) LPC Interface Bridge (rev 01)
00:1f.2 IDE interface: Intel Corporation 82801GBM/GHM (ICH7-M Family) SATA Controller [IDE mode] (rev 01)
00:1f.3 SMBus: Intel Corporation NM10/ICH7 Family SMBus Controller (rev 01)
03:01.0 CardBus bridge: O2 Micro, Inc. OZ601/6912/711E0 CardBus/SmartCardBus Controller (rev 40)
09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5752 Gigabit Ethernet PCI Express (rev 02)
0c:00.0 Network controller: Intel Corporation PRO/Wireless 3945ABG [Golan] Network Connection (rev 02)
```

We find that I have 2 present network cards (line 19 and 20):
* Ethernet controller: Broadcom Corporation (wired network adapter)
* Network controller: Intel Corporation (wireless network card)


I also have the graphic and audio card (line 3 and 5):
* VGA compatible controller: Intel Corporation Mobile 945GM/GMS
* Audio device: Intel Corporation NM10 / ICH7


The lspci command can be run by the single user, however if you want more detail with the -v option I advise you to run the command under the root user. I did not copy all the rows returned because there are a lot of lines. I focus on the 4 devices mentioned earlier:

### example lspci verbose
```
# lspci with verboce
$ sudo lspci -v
00:00.0 Host bridge: Intel Corporation Mobile 945GM/PM/GMS, 943/940GML and 945GT Express Memory Controller Hub (rev 03)
        Subsystem: Dell Device 01c2
        Flags: bus master, fast devsel, latency 0
        Capabilities: [e0] Vendor Specific Information: Len=09 <?>
        Kernel driver in use: agpgart-intel
 
00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS, 943/940GML Express Integrated Graphics Controller (rev 03) (prog-if 00 [VGA controller])
        Subsystem: Dell Device 01c2
        Flags: bus master, fast devsel, latency 0, IRQ 16
        Memory at eff00000 (32-bit, non-prefetchable) [size=512K]
        I/O ports at eff8 [size=8]
        Memory at d0000000 (32-bit, prefetchable) [size=256M]
        Memory at efec0000 (32-bit, non-prefetchable) [size=256K]
        Expansion ROM at <unassigned> [disabled]
        Capabilities: [90] MSI: Enable- Count=1/1 Maskable- 64bit-
        Capabilities: [d0] Power Management version 2
        Kernel driver in use: i915
 
00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/GME, 943/940GML Express Integrated Graphics Controller (rev 03)
        Subsystem: Dell Device 01c2
        Flags: bus master, fast devsel, latency 0
        Memory at eff80000 (32-bit, non-prefetchable) [size=512K]
        Capabilities: [d0] Power Management version 2
 
00:1b.0 Audio device: Intel Corporation NM10/ICH7 Family High Definition Audio Controller (rev 01)
        Subsystem: Dell Device 01c2
        Flags: bus master, fast devsel, latency 0, IRQ 43
        Memory at efebc000 (64-bit, non-prefetchable) [size=16K]
        Capabilities: [50] Power Management version 2
        Capabilities: [60] MSI: Enable+ Count=1/1 Maskable- 64bit+
        Capabilities: [70] Express Root Complex Integrated Endpoint, MSI 00
        Capabilities: [100] Virtual Channel
        Capabilities: [130] Root Complex Link
        Kernel driver in use: snd_hda_intel
 
[[ CUT OUTPUT ]]
 
 
09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5752 Gigabit Ethernet PCI Express (rev 02)
        Subsystem: Dell Latitude D620
        Flags: bus master, fast devsel, latency 0, IRQ 45
        Memory at efcf0000 (64-bit, non-prefetchable) [size=64K]
        Expansion ROM at <ignored> [disabled]
        Capabilities: [48] Power Management version 2
        Capabilities: [50] Vital Product Data
        Capabilities: [58] MSI: Enable+ Count=1/8 Maskable- 64bit+
        Capabilities: [d0] Express Endpoint, MSI 00
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [13c] Virtual Channel
        Kernel driver in use: tg3
 
0c:00.0 Network controller: Intel Corporation PRO/Wireless 3945ABG [Golan] Network Connection (rev 02)
        Subsystem: Intel Corporation Device 1020
        Flags: bus master, fast devsel, latency 0, IRQ 44
        Memory at efdff000 (32-bit, non-prefetchable) [size=4K]
        Capabilities: [c8] Power Management version 2
        Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+
        Capabilities: [e0] Express Legacy Endpoint, MSI 00
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [140] Device Serial Number 00-18-de-ff-ff-17-93-6f
        Kernel driver in use: iwl3945
```

I would particularly like to pay attention to the lines containing the information "Kernel driver in use", this tells us which driver / driver the system uses to communicate with the device. If we take back our 4 currencies mentioned earlier:
* Ethernet controller: Broadcom Corporation (wired network adapter): tg3
* Network controller: Intel Corporation (wireless network card): iwl3945
* VGA compatible controller: Intel Mobile Corporation 945GM / GMS: i915
* Audio device: Intel Corporation NM10 / ICH7: snd_hda_intel


We will return to the drivers very soon I will like that we continue to list the system peripherals!

## List USB devices
With the proliferation of USB device, it is important to be able to list them. It may be even more important to be able to do this because its latest can be plugged into Hot! We find the same command syntax, lsusb and with the -v option we will have more information. But beware -v gives a lot more information! The concept remains the same use sudo with -v in order to have all the information.

### example lsusb
 
``` 
# example lsusb
$ lsusb
Bus 001 Device 003: ID 0930:6545 Toshiba Corp. Kingston DataTraveler 102 Flash Drive / HEMA Flash Drive 2 GB / PNY Attache 4GB Stick
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 004 Device 002: ID 0461:4d22 Primax Electronics, Ltd 
Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 002 Device 004: ID 0b97:7762 O2 Micro, Inc. Oz776 SmartCard Reader
Bus 002 Device 003: ID 0b97:7761 O2 Micro, Inc. Oz776 1.1 Hub
Bus 002 Device 002: ID 413c:a005 Dell Computer Corp. Internal 2.0 Hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
```

If we look in the example above I have:
* A connected USB data key: Bus 001 Device 003: ID 0930: 6545 Toshiba Corp. Kingston DataTraveler 102 Flash Drive / HEMA Flash Drive 2GB / PNY Tie 4GB Stick
* a mouse (should know it: P): Bus 004 Device 002: ID 0461: 4d22 Primax Electronics, Ltd
* An internal card reader: Bus 002 Device 004: ID 0b97: 7762 O2 Micro, Inc. Oz776 SmartCard Reader


How did I do to know that Primax Electronics is a mouse? With the information transmitted by lsusb I could not know it but with the option -v I have the information. It is possible to transmit in parameter a specific device interrogated to have all the information!


### example lsusb verbose for mouse

``` 
# Display information on the mouse.
$ sudo  lsusb -v -s 004:002
 
Bus 004 Device 002: ID 0461:4d22 Primax Electronics, Ltd 
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            0 (Defined at Interface level)
  bDeviceSubClass         0 
  bDeviceProtocol         0 
  bMaxPacketSize0         8
  idVendor           0x0461 Primax Electronics, Ltd
  idProduct          0x4d22 
  bcdDevice            2.00
  iManufacturer           0 
  iProduct                2 USB Optical Mouse
  iSerial                 0 
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength           34
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          0 
    bmAttributes         0xa0
      (Bus Powered)
      Remote Wakeup
    MaxPower              100mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass         3 Human Interface Device
      bInterfaceSubClass      1 Boot Interface Subclass
      bInterfaceProtocol      2 Mouse
      iInterface              0 
        HID Device Descriptor:
          bLength                 9
          bDescriptorType        33
          bcdHID               1.11
          bCountryCode            0 Not supported
          bNumDescriptors         1
          bDescriptorType        34 Report
          wDescriptorLength      52
         Report Descriptors: 
           ** UNAVAILABLE **
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0004  1x 4 bytes
        bInterval              10
Device Status:     0x0000
  (Bus Powered)
```

As you can see in line 14 we clearly see that this is a Optical Mouse type device, in addition to line 38 the device type is Human Interface. Here is an example of a command to extract information from lsub with several criteria:

### lsusb information extraction

```
# use of egrep
$ sudo lsusb -v  | egrep 'bInterfaceClass|iProduct|idVendor|^Bus' | tr -s " " 
Bus 001 Device 003: ID 0930:6545 Toshiba Corp. Kingston DataTraveler 102 Flash Drive / HEMA Flash Drive 2 GB / PNY Attache 4GB Stick
 idVendor 0x0930 Toshiba Corp.
 iProduct 2 DataTraveler G3 
 bInterfaceClass 8 Mass Storage
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
 idVendor 0x1d6b Linux Foundation
 iProduct 2 EHCI Host Controller
 bInterfaceClass 9 Hub
Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
 idVendor 0x1d6b Linux Foundation
 iProduct 2 UHCI Host Controller
 bInterfaceClass 9 Hub
Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
 idVendor 0x1d6b Linux Foundation
 iProduct 2 UHCI Host Controller
 bInterfaceClass 9 Hub
Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
 idVendor 0x1d6b Linux Foundation
 iProduct 2 UHCI Host Controller
 bInterfaceClass 9 Hub
Bus 002 Device 004: ID 0b97:7762 O2 Micro, Inc. Oz776 SmartCard Reader
 idVendor 0x0b97 O2 Micro, Inc.
 iProduct 2 O2Micro CCID SC Reader
 bInterfaceClass 11 Chip/SmartCard
Bus 002 Device 003: ID 0b97:7761 O2 Micro, Inc. Oz776 1.1 Hub
 idVendor 0x0b97 O2 Micro, Inc.
 iProduct 0 
 bInterfaceClass 9 Hub
Bus 002 Device 002: ID 413c:a005 Dell Computer Corp. Internal 2.0 Hub
 idVendor 0x413c Dell Computer Corp.
 iProduct 0 
 bInterfaceClass 9 Hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
 idVendor 0x1d6b Linux Foundation
 iProduct 2 UHCI Host Controller
 bInterfaceClass 9 Hub
``` 

Here I use egrep with | for it to return several lines with several criteria, this allows me to keep only the essential.


Thanks to lsusb I can see "live" the equipment you connect, plus we can collect a wealth of information. We will come back to this command when we process udev, the information return by lsusb will allow us to identify a device and perform a specific action, to follow.


## list the hardware information of the system
Now that we have seen how to collect information about "removable" devices and "extention" (PCI) cards, let's look at the system information. It is possible to extract information from the motherboard, CPU, memory, etc. We will see the application dmidecode that allows us to perform this operation, it is the same application that is used by OcsInventory / GLPI.


dmidecode returns the information System Management Bios (SMBios), here is what the result resems, I cut the output to keep only the parts relevant, I invite you to try it on your system:

### example dmidecode

```
$ sudo dmidecode
[[ CUT OUTPUT  ]]
Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
        Vendor: Dell Inc.
        Version: A09
        Release Date: 04/03/2008
        Address: 0xF0000
        Runtime Size: 64 kB
        ROM Size: 2048 kB
        Characteristics:
                ISA is supported
                PCI is supported
                PC Card (PCMCIA) is supported
                PNP is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                3.5''/720 kB floppy services are supported (int 13h)
                Print screen service is supported (int 5h)
                8042 keyboard services are supported (int 9h)
                Serial services are supported (int 14h)
                Printer services are supported (int 17h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                AGP is supported
                Smart battery is supported
                BIOS boot specification is supported
                Function key-initiated network boot is supported
                Targeted content distribution is supported
        BIOS Revision: 0.9
        Firmware Revision: 0.9
 
Handle 0x0100, DMI type 1, 27 bytes
System Information
        Manufacturer: Dell Inc.
        Product Name: Latitude D630                   
        Version: Not Specified
        Serial Number: 3ZGBXF1
        UUID: 44454C4C-5A00-1047-8042-B3C04F584631
        Wake-up Type: Power Switch
        SKU Number: Not Specified
        Family:  
 
Handle 0x0200, DMI type 2, 9 bytes
Base Board Information
        Manufacturer: Dell Inc.
        Product Name: 0KU184
        Version:    
        Serial Number: .3ZGBXF1.CN1296182R7975.
        Asset Tag:           
 
Handle 0x0300, DMI type 3, 13 bytes
Chassis Information
        Manufacturer: Dell Inc.
        Type: Portable
        Lock: Not Present
        Version: Not Specified
        Serial Number: 3ZGBXF1
        Asset Tag: Not Specified
        Boot-up State: Safe
        Power Supply State: Safe
        Thermal State: Safe
        Security Status: None
 
Processor Information
        Socket Designation: Microprocessor
        Type: Central Processor
        Family: Core 2 Duo
        Manufacturer: Intel
        ID: FB 06 00 00 FF FB EB BF
        Signature: Type 0, Family 6, Model 15, Stepping 11
        Flags:
                FPU (Floating-point unit on-chip)
                VME (Virtual mode extension)
                DE (Debugging extension)
                PSE (Page size extension)
                TSC (Time stamp counter)
                MSR (Model specific registers)
                PAE (Physical address extension)
                MCE (Machine check exception)
                CX8 (CMPXCHG8 instruction supported)
                APIC (On-chip APIC hardware supported)
                SEP (Fast system call)
                MTRR (Memory type range registers)
                PGE (Page global enable)
                MCA (Machine check architecture)
                CMOV (Conditional move instruction supported)
                PAT (Page attribute table)
                PSE-36 (36-bit page size extension)
                CLFSH (CLFLUSH instruction supported)
                DS (Debug store)
                ACPI (ACPI supported)
                MMX (MMX technology supported)
                FXSR (FXSAVE and FXSTOR instructions supported)
                SSE (Streaming SIMD extensions)
                SSE2 (Streaming SIMD extensions 2)
                SS (Self-snoop)
                HTT (Multi-threading)
                TM (Thermal monitor supported)
                PBE (Pending break enabled)
        Version: Not Specified
        Voltage: 3.3 V
        External Clock: 200 MHz
        Max Speed: 2200 MHz
        Current Speed: 2200 MHz
        Status: Populated, Enabled
        Upgrade: None
        L1 Cache Handle: 0x0700
        L2 Cache Handle: 0x0701
        L3 Cache Handle: Not Provided
        Serial Number: Not Specified
        Asset Tag: Not Specified
        Part Number: Not Specified
        Core Count: 2
        Core Enabled: 2
        Thread Count: 2
        Characteristics:
                64-bit capable
 
 [[ CUT OUTPUT ]]
 ```
 
If you have run it on your system you find that there is a lot, a lot of information, you have to have an idea of what you are looking for when you use this command. I use this command when I want to know:
* The serial number of the system as well as the manufacturer
* To know the flags of the hard disk in order to know if it supports natively the virtualization
* Know how much memory slot are used, what is the size of each bar and know if there is any free.

## Peripherals and the kernel
As mentioned in the operating system section, the Linux kernel realizes the link between the hardware and the software. The concept of the driver is a little different in Linux because of the open-source nature and also because the hardware companies do not always offer the drivers for their device.


A special feature in Linux is that the driver is often generic, if I take the case of network cards, I can have several different providers but it uses all the same drivers. Just because when detecting hardware The Linux kernel looks at the chipset that is used and chose the associated driver. Whether the card is Intel, Dell, IBM or Ziatugs if it's the same instructions I do not see the point of now several drivers: D. This applies for the device set! We also find "generic" drivers that are sometimes offers less performance but that allows us to start the system, we find this case especially for the graphics card, this allows us all the same to have a display and adjust by following the pilot.


A large majority of drivers under GNU / Linux are free! Of course there are more free than others and sometimes we even have the choice, if we take the case of Nvidia, the company offers a proprietary driver for these graphics cards, of course this driver allows to use all features of the card with the most optimal 3D acceleration because the company knows all the specs of the card and has the Bible to communicate with it. By cons there is also a free driver, however less powerful in terms of 3D and other why because the develop not access to the bible communication they are therefore obliged to do the reverse engenering to design their driver. There are other cases such as wireless broadcom network cards that were closed for a while, but in recent years the companies open more and more their drivers.


With Ubuntu, the kernel comes with proprietary drivers, if you want to be sure not to have some I recommend you use: http://www.gnewsense.org/, but attention will also have to make sure that your hardware is fully supported: P, mainly the wireless network card: P.


## The kernel and its modules
The Linux kernel allows us to hot load modules, these modules are the equivalent of driver, in fact these modules allow us to add new functionality to the kernel in order to: communicate with a device, perform operations at the system level, ... If we take the case of GNU / Linux embedded system this feature is remove and all modules and functionality are directly compiled into the kernel without loading them. For embedded systems this is more efficient in the case of desktop, we are likely to add and remove equipment more easily so it is more convenient to have these modules that load and unload as needed. Here is a small diagram:

## List modules (lsmod)
Distributions "modern" offers a panoply of module available which is waiting to be used, if we look at now we already have a list of module used, to list the modules used the command lsmod (list module):

### example lsmod

```
# List modules
$ lsmod
nfnetlink_acct          3772  0 
xt_connmark             1853  2 
iptable_nat             3366  0 
nf_conntrack_ipv4       9206  3 
nf_defrag_ipv4          1411  1 nf_conntrack_ipv4
nf_nat_ipv4             3576  1 iptable_nat
nf_nat                 12343  2 nf_nat_ipv4,iptable_nat
nf_conntrack           73690  5 nf_nat,nf_nat_ipv4,xt_connmark,iptable_nat,nf_conntrack_ipv4
iptable_mangle          1592  1 
iptable_filter          1496  0 
ip_tables              17282  3 iptable_filter,iptable_mangle,iptable_nat
x_tables               17359  4 ip_tables,iptable_filter,xt_connmark,iptable_mangle
nfnetlink               4301  2 nfnetlink_acct
joydev                  9671  0 
snd_hda_codec_idt      37852  1 
pcmcia                 45396  0 
coretemp                6334  0 
psmouse                85428  0 
yenta_socket           32385  0 
kvm                   389093  0 
arc4                    2008  2 
iwl3945                55252  0 
snd_hda_intel          36904  0 
snd_hda_codec         149569  2 snd_hda_codec_idt,snd_hda_intel
snd_hwdep               6340  1 snd_hda_codec
snd_pcm                77709  2 snd_hda_codec,snd_hda_intel
gpio_ich                4536  0 
iTCO_wdt                5407  0 
pcmcia_rsrc             9112  1 yenta_socket
iTCO_vendor_support     1937  1 iTCO_wdt
snd_page_alloc          7242  2 snd_pcm,snd_hda_intel
iwlegacy               49297  1 iwl3945
snd_timer              18726  1 snd_pcm
i915                  656950  3 
snd                    59173  6 snd_hwdep,snd_timer,snd_hda_codec_idt,snd_pcm,snd_hda_codec,snd_hda_intel
dell_laptop             8859  0 
pcmcia_core            14264  3 pcmcia,pcmcia_rsrc,yenta_socket
dcdbas                  6463  1 dell_laptop
microcode              15024  0 
dell_wmi                1493  0 
sparse_keymap           3154  1 dell_wmi
evdev                  10989  11 
mac80211              466554  2 iwl3945,iwlegacy
serio_raw               5049  0 
tg3                   155658  0 
soundcore               5450  1 snd
pcspkr                  2035  0 
drm_kms_helper         36286  1 i915
cfg80211              412854  3 iwl3945,iwlegacy,mac80211
i2c_i801               11277  0 
lpc_ich                13120  0 
ptp                     8276  1 tg3
pps_core                8961  1 ptp
libphy                 20342  1 tg3
drm                   238206  4 i915,drm_kms_helper
i2c_algo_bit            5399  1 i915
i2c_core               24164  5 drm,i915,i2c_i801,drm_kms_helper,i2c_algo_bit
rfkill                 15651  3 cfg80211
thermal                 8532  0 
shpchp                 25465  0 
wmi                     8419  1 dell_wmi
button                  4677  1 i915
intel_agp              10880  1 i915
intel_gtt              12664  3 i915,intel_agp
video                  11196  1 i915
battery                 6837  0 
ac                      3332  0 
acpi_cpufreq           10779  1 
processor              24999  3 acpi_cpufreq
nfs                   191701  0 
lockd                  76942  1 nfs
sunrpc                231063  2 nfs,lockd
fscache                47028  1 nfs
ext4                  474187  1 
crc16                   1367  1 ext4
mbcache                 6082  1 ext4
jbd2                   83504  1 ext4
sd_mod                 30789  2 
sr_mod                 14898  0 
cdrom                  34848  1 sr_mod
ata_generic             3410  0 
pata_acpi               3395  0 
ata_piix               25088  1 
firewire_ohci          31877  0 
libata                170792  3 pata_acpi,ata_generic,ata_piix
scsi_mod              130669  3 libata,sd_mod,sr_mod
firewire_core          52259  1 firewire_ohci
crc_itu_t               1371  1 firewire_core
uhci_hcd               24795  0 
ehci_pci                4000  0 
ehci_hcd               59220  1 ehci_pci
usbcore               179880  3 uhci_hcd,ehci_hcd,ehci_pci
usb_common              1656  1 usbcore
``` 

I deliberately did not cut the result to properly visualize all the modules that are loaded, as we can see this is long and yet we do not have much device. So I will highlight some module to demonstrate that when speaking of module this does not necessarily a device but a feature:
* coretemp : Intel Core temperature monitor
* gpio_ich : GPIO interface for Intel ICH series
* pcmcia : PCMCIA Driver Services
* pcspkr : PC Speaker beeper driver
* battery et ac : ACPI Battery Driver et ACPI AC Adapter Driver
* ext4 : Fourth Extended Filesystem , type of the system queue equivalent to fat32 or ntfs
* uhci_hcd : USB Universal Host Controller Interface driver
* ehci_hcd : USB 2.0 'Enhanced' Host Controller (EHCI) Driver


Of course I do not list all the drivers because there are many but the goal here was mostly to demonstrate that the modules are not necessarily associated with a physical device, but can be a simple extension of functionality. You may ask me or can I find information on the modules that are loading? By need to go to a website, there is a modinfo command, here is an example with the module coretemp

### example modinfo with coretemp

```
# example of modinfo to display information about a module.
$ modinfo coretemp
filename:       /lib/modules/3.12.1-1-ARCH/kernel/drivers/hwmon/coretemp.ko.gz
license:        GPL
description:    Intel Core temperature monitor
author:         Rudolf Marek <r.marek@assembler.cz>
alias:          x86cpu:vendor:0000:family:*:model:*:feature:*00E7*
depends:        
intree:         Y
vermagic:       3.12.1-1-ARCH SMP preempt mod_unload modversions 
parm:           tjmax:TjMax value in degrees Celsius (int)
``` 

As you can see, there is the license, the description of the module, the dependencies of the latter (here none) and the parameters that could be associated with the module (here TjMax).


Take again the result of the command lspci we had seen that this command indicates us the modules which the cards uses, we will take a module and display the information on this last one:

### show pci modules and module information

```
# I extract the information from lspci with grep that the line starts with 0 (^ 0) or the line contains Kernel modules (| Kernel modules)
$ lspci  -v | egrep --color '^0|Kernel modules'
00:00.0 Host bridge: Intel Corporation Mobile PM965/GM965/GL960 Memory Controller Hub (rev 0c)
        Kernel modules: intel_agp
00:02.0 VGA compatible controller: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller (primary) (rev 0c) (prog-if 00 [VGA controller])
        Kernel modules: i915
00:02.1 Display controller: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller (secondary) (rev 0c)
00:1a.0 USB controller: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #4 (rev 02) (prog-if 00 [UHCI])
        Kernel modules: uhci_hcd
00:1a.1 USB controller: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #5 (rev 02) (prog-if 00 [UHCI])
        Kernel modules: uhci_hcd
00:1a.7 USB controller: Intel Corporation 82801H (ICH8 Family) USB2 EHCI Controller #2 (rev 02) (prog-if 20 [EHCI])
        Kernel modules: ehci_pci
00:1b.0 Audio device: Intel Corporation 82801H (ICH8 Family) HD Audio Controller (rev 02)
        Kernel modules: snd_hda_intel
00:1c.0 PCI bridge: Intel Corporation 82801H (ICH8 Family) PCI Express Port 1 (rev 02) (prog-if 00 [Normal decode])
        Kernel modules: shpchp
00:1c.1 PCI bridge: Intel Corporation 82801H (ICH8 Family) PCI Express Port 2 (rev 02) (prog-if 00 [Normal decode])
        Kernel modules: shpchp
00:1c.5 PCI bridge: Intel Corporation 82801H (ICH8 Family) PCI Express Port 6 (rev 02) (prog-if 00 [Normal decode])
        Kernel modules: shpchp
00:1d.0 USB controller: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #1 (rev 02) (prog-if 00 [UHCI])
        Kernel modules: uhci_hcd
00:1d.1 USB controller: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #2 (rev 02) (prog-if 00 [UHCI])
        Kernel modules: uhci_hcd
00:1d.2 USB controller: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #3 (rev 02) (prog-if 00 [UHCI])
        Kernel modules: uhci_hcd
00:1d.7 USB controller: Intel Corporation 82801H (ICH8 Family) USB2 EHCI Controller #1 (rev 02) (prog-if 20 [EHCI])
        Kernel modules: ehci_pci
00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev f2) (prog-if 01 [Subtractive decode])
00:1f.0 ISA bridge: Intel Corporation 82801HM (ICH8M) LPC Interface Controller (rev 02)
        Kernel modules: lpc_ich
00:1f.1 IDE interface: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) IDE Controller (rev 02) (prog-if 8a [Master SecP PriP])
        Kernel modules: ata_piix, pata_acpi, ata_generic
00:1f.2 IDE interface: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) SATA Controller [IDE mode] (rev 02) (prog-if 8f [Master SecP SecO PriP PriO])
        Kernel modules: ata_piix, pata_acpi, ata_generic
00:1f.3 SMBus: Intel Corporation 82801H (ICH8 Family) SMBus Controller (rev 02)
        Kernel modules: i2c_i801
03:01.0 CardBus bridge: O2 Micro, Inc. Cardbus bridge (rev 21)
        Kernel modules: yenta_socket
03:01.4 FireWire (IEEE 1394): O2 Micro, Inc. Firewire (IEEE 1394) (rev 02) (prog-if 10 [OHCI])
        Kernel modules: firewire_ohci
09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5755M Gigabit Ethernet PCI Express (rev 02)
        Kernel modules: tg3
0c:00.0 Network controller: Intel Corporation PRO/Wireless 3945ABG [Golan] Network Connection (rev 02)
        Kernel modules: iwl3945
 
# Display information on the wired network card
$ modinfo tg3
filename:       /lib/modules/3.12.1-1-ARCH/kernel/drivers/net/ethernet/broadcom/tg3.ko.gz
firmware:       tigon/tg3_tso5.bin
firmware:       tigon/tg3_tso.bin
firmware:       tigon/tg3.bin
version:        3.133
license:        GPL
description:    Broadcom Tigon3 ethernet driver
author:         David S. Miller (davem@redhat.com) and Jeff Garzik (jgarzik@pobox.com)
srcversion:     5F6693B7BE37032F61B0883
[[ OUTPUT COUPÉ ]]
depends:        libphy,ptp
intree:         Y
vermagic:       3.12.1-1-ARCH SMP preempt mod_unload modversions 
parm:           tg3_debug:Tigon3 bitmapped debugging message enable value (int)
 
 
# Display information on the network card without a line
$ modinfo iwl3945
filename:       /lib/modules/3.12.1-1-ARCH/kernel/drivers/net/wireless/iwlegacy/iwl3945.ko.gz
firmware:       iwlwifi-3945-2.ucode
license:        GPL
author:         Copyright(c) 2003-2011 Intel Corporation <ilw@linux.intel.com>
version:        in-tree:s
description:    Intel(R) PRO/Wireless 3945ABG/BG Network Connection driver for Linux
srcversion:     102CBF0C44B023F828879B7
alias:          pci:v00008086d00004227sv*sd*bc*sc*i*
alias:          pci:v00008086d00004222sv*sd*bc*sc*i*
alias:          pci:v00008086d00004227sv*sd00001014bc*sc*i*
alias:          pci:v00008086d00004222sv*sd00001044bc*sc*i*
alias:          pci:v00008086d00004222sv*sd00001034bc*sc*i*
alias:          pci:v00008086d00004222sv*sd00001005bc*sc*i*
depends:        iwlegacy,cfg80211,mac80211
intree:         Y
vermagic:       3.12.1-1-ARCH SMP preempt mod_unload modversions 
parm:           antenna:select antenna (1=Main, 2=Aux, default 0 [both]) (int)
parm:           swcrypto:using software crypto (default 1 [software]) (int)
parm:           disable_hw_scan:disable hardware scanning (default 1) (int)
parm:           fw_restart:restart firmware in case of error (int)
 
# displays information about the sound card module
$ modinfo snd_hda_intel
filename:       /lib/modules/3.12.1-1-ARCH/kernel/sound/pci/hda/snd-hda-intel.ko.gz
description:    Intel HDA driver
license:        GPL
alias:          pci:v00001022d*sv*sd*bc04sc03i00*
alias:          pci:v00001002d*sv*sd*bc04sc03i00*
[[ OUTPUT COUPÉ ]]
depends:        snd-hda-codec,snd-pcm,snd,snd-page-alloc
intree:         Y
vermagic:       3.12.1-1-ARCH SMP preempt mod_unload modversions 
parm:           index:Index value for Intel HD audio interface. (array of int)
parm:           id:ID string for Intel HD audio interface. (array of charp)
parm:           enable:Enable Intel HD audio interface. (array of bool)
parm:           model:Use the given board model. (array of charp)
parm:           position_fix:DMA pointer read method.(-1 = system default, 0 = auto, 1 = LPIB, 2 = POSBUF, 3 = VIACOMBO, 4 = COMBO). (array of int)
parm:           bdl_pos_adj:BDL position adjustment offset. (array of int)
parm:           probe_mask:Bitmask to probe codecs (default = -1). (array of int)
parm:           probe_only:Only probing and no codec initialization. (array of int)
parm:           jackpoll_ms:Ms between polling for jack events (default = 0, using unsol events only) (array of int)
parm:           single_cmd:Use single command to communicate with codecs (for debugging only). (bool)
parm:           enable_msi:Enable Message Signaled Interrupt (MSI) (bint)
parm:           patch:Patch file for Intel HD audio interface. (array of charp)
parm:           beep_mode:Select HDA Beep registration mode (0=off, 1=on) (default=1). (array of bool)
parm:           power_save:Automatic power-saving timeout (in second, 0 = disable). (xint)
parm:           power_save_controller:Reset controller in power save mode. (bool)
parm:           align_buffer_size:Force buffer and period sizes to be multiple of 128 bytes. (bint)
parm:           snoop:Enable/disable snooping (bool)
```

As we can see the sound card to a lot of parameter available!

## Load and unload a module (modprobe and rmmod)
Now that we have seen how to list the modules we will see how to load them (modprobe) and unload (rmmod) by the way it is very rare that we have to do that! We will see a little later the udev system that realizes dynamic this operation when we add a device or delete it. I present here this feature for more information than per requires, however while we are covering the subject why not take advantage of it. To load and unload a module in the kernel you must have administrator permissions, so we will have to perform this operation with sudo or by being root.


We saw in the list of modules that of the network card tg3, in the following example I will unload and reload the module:

### list, unload and recharge module tg3
```
# list the module containing the pattern tg3
$ lsmod | grep tg3
tg3                   155658  0 
ptp                     8276  1 tg3
libphy                 20342  1 tg3
 
# unload the module
$ sudo rmmod tg3
# relist modules and find that there is no module tg3
 
# reloads the module
$ sudo modprobe tg3
 
$ lsmod | grep tg3
tg3                   155658  0 
ptp                     8276  1 tg3
libphy                 20342  1 tg3
```

As mentioned earlier I do not advocate this approach other than to test, it is not viable for use in production or everyday for a desktop to enter command lines at each reboot of the system moreover these commands must be realized as the root user. However it is interesting to be able to test, we saw earlier with the use of the command modinfo that it is possible to pass parameters to the module, this is done simply by adding the parameter after the argument of the module to modprobe.

### tg3 module information and module loading with parameter.

```
# list the parameters available at tg3
$ modinfo tg3 | grep parm
parm:           tg3_debug:Tigon3 bitmapped debugging message enable value (int)
 
 
# add an option
$ sudo modprobe tg3 patate=10
# le module ne renvoie pas d'erreur et se charge.
 
# ajout d'une option
$ sudo modprobe tg3 tg3_debug=10
``` 
 
This option can also be set in the configuration file /etc/modprobe.d/FileName.conf the file name is arbitrary the system loads all the files with the extention .conf here is an example of the / etc file /modprobe.d/alsa-base.conf


### example information modprobe.d / alsa-base.conf

```
# Load saa7134-alsa instead of saa7134 (which gets dragged in by it anyway)
install saa7134 /sbin/modprobe --ignore-install saa7134 $CMDLINE_OPTS && { /sbin/modprobe --quiet --use-blacklist saa7134-alsa ; : ; }
# Prevent abnormal drivers from grabbing index 0
options bt87x index=-2
options cx88_alsa index=-2
options saa7134-alsa index=-2
options snd-atiixp-modem index=-2
options snd-intel8x0m index=-2
options snd-via82xx-modem index=-2
options snd-usb-audio index=-2
options snd-usb-caiaq index=-2
``` 
 
## Message from the kernel
When the load system, the kernel will realize all the detections of the material. When a new device is connected, the system will load the module accordingly or the module will generate an event at the kernel, the latter to write a log. It is possible by using the dmesg command to obtain this information. Here is an example of dmesg, of course it is not always easy to read it because we will see all PCI cards pass, etc.

### example dmesg

```
# example bash
$ dmesg
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Linux version 3.2.0-57-generic-pae (buildd@lamiak) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #87-Ubuntu SMP Tue Nov 12 21:57:43 UTC 2013 (Ubuntu 3.2.0-57.87-generic-pae 3.2.52)
[    0.000000] KERNEL supported cpus:
[    0.000000]   Intel GenuineIntel
[    0.000000]   AMD AuthenticAMD
[    0.000000]   NSC Geode by NSC
[    0.000000]   Cyrix CyrixInstead
[    0.000000]   Centaur CentaurHauls
[    0.000000]   Transmeta GenuineTMx86
[    0.000000]   Transmeta TransmetaCPU
[    0.000000]   UMC UMC UMC UMC
[[ CUT OUTPUT ]]
 
[   22.334400] parport_pc 00:05: reported by Plug and Play ACPI
[   22.334453] parport0: PC-style at 0x378 (0x778), irq 7, dma 3 [PCSPP,TRISTATE,COMPAT,ECP,DMA]
[   22.371152] device-mapper: multipath: version 1.3.1 loaded
[   22.431573] ACPI: PCI Interrupt Link [LAZA] enabled at IRQ 22
[   22.431582] snd_hda_intel 0000:00:05.0: PCI INT B -> Link[LAZA] -> GSI 22 (level, low) -> IRQ 22
[   22.431586] hda_intel: Disabling MSI
[   22.431622] snd_hda_intel 0000:00:05.0: setting latency timer to 64
[   22.432242] lp0: using parport0 (interrupt-driven).
[   22.444540] nvidia: module license 'NVIDIA' taints kernel.
[   22.444545] Disabling lock debugging due to kernel taint
[   22.781575] ACPI: PCI Interrupt Link [LNED] enabled at IRQ 19
[   22.781600] nvidia 0000:02:00.0: PCI INT A -> Link[LNED] -> GSI 19 (level, low) -> IRQ 19
[   22.781610] nvidia 0000:02:00.0: setting latency timer to 64
[[ CUT OUTPUT ]]
 
[    1.492540] scsi 2:0:0:0: Direct-Access     ATA      ST31000524AS     JC4B PQ: 0 ANSI: 5
[    1.492727] sd 2:0:0:0: [sda] 1953525168 512-byte logical blocks: (1.00 TB/931 GiB)
[    1.492734] sd 2:0:0:0: Attached scsi generic sg0 type 0
[    1.492776] sd 2:0:0:0: [sda] Write Protect is off
[    1.492780] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00
[    1.492834] sd 2:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn t support DPO or FUA
[    1.500133] ata5.00: configured for UDMA/100
[    1.514237]  sda: sda1 sda2 sda3
[    1.514635] sd 2:0:0:0: [sda] Attached SCSI disk
    1.660024] usb 2-1: new low-speed USB device number 2 using ohci_hcd
[    1.960054] ata4: SATA link up 1.5 Gbps (SStatus 113 SControl 300)
[    1.968505] ata4.00: ATA-8: ST3500320AS, SD15, max UDMA/133
[    1.968510] ata4.00: 976773168 sectors, multi 16: LBA48 NCQ (depth 0/32)
[    1.984493] ata4.00: configured for UDMA/133
[    1.984671] scsi 3:0:0:0: Direct-Access     ATA      ST3500320AS      SD15 PQ: 0 ANSI: 5
[    1.984820] sd 3:0:0:0: [sdb] 976773168 512-byte logical blocks: (500 GB/465 GiB)
[    1.984853] sd 3:0:0:0: Attached scsi generic sg1 type 0
[    1.984868] sd 3:0:0:0: [sdb] Write Protect is off
[    1.984871] sd 3:0:0:0: [sdb] Mode Sense: 00 3a 00 00
[    1.984891] sd 3:0:0:0: [sdb] Write cache: enabled, read cache: enabled, doesn t support DPO or FUA
[    1.988251] scsi 4:0:0:0: CD-ROM            HL-DT-ST DVDRAM GH20NS10  EL00 PQ: 0 ANSI: 5
[    1.990491]  sdb: sdb1 sdb2
[    1.990884] sd 3:0:0:0: [sdb] Attached SCSI disk
[    1.993339] sr0: scsi3-mmc drive: 48x/48x writer dvd-ram cd/rw xa/form2 cdda tray
[    1.993342] cdrom: Uniform CD-ROM driver Revision: 3.20
[    1.993466] sr 4:0:0:0: Attached scsi CD-ROM sr0
[    1.993593] sr 4:0:0:0: Attached scsi generic sg2 type 5
[[ CUT OUTPUT ]]
 
 
[26467.825422] tg3.c:v3.133 (Jul 29, 2013)
[26467.861300] tg3 0000:09:00.0: irq 46 for MSI/MSI-X
[26467.868040] tg3 0000:09:00.0 eth0: Tigon3 [partno(BCM95755m) rev a002] (PCI Express) MAC address 00:1c:23:41:6d:eb
[26467.868046] tg3 0000:09:00.0 eth0: attached PHY is 5755 (10/100/1000Base-T Ethernet) (WireSpeed[1], EEE[0])
[26467.868050] tg3 0000:09:00.0 eth0: RXcsums[1] LinkChgREG[0] MIirq[0] ASF[0] TSOcap[1]
[26467.868054] tg3 0000:09:00.0 eth0: dma_rwctrl[76180000] dma_mask[64-bit]
[26467.896710] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
[26895.116779] tg3: unknown parameter 'patate' ignored
[26895.116982] tg3.c:v3.133 (Jul 29, 2013)
[26895.161137] tg3 0000:09:00.0 eth0: Tigon3 [partno(BCM95755m) rev a002] (PCI Express) MAC address 00:1c:23:41:6d:eb
[26895.161142] tg3 0000:09:00.0 eth0: attached PHY is 5755 (10/100/1000Base-T Ethernet) (WireSpeed[1], EEE[0])
[26895.161146] tg3 0000:09:00.0 eth0: RXcsums[1] LinkChgREG[0] MIirq[0] ASF[0] TSOcap[1]
[26895.161148] tg3 0000:09:00.0 eth0: dma_rwctrl[76180000] dma_mask[64-bit]
[26895.161656] tg3 0000:09:00.0: irq 46 for MSI/MSI-X
[26895.197172] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
[26914.509842] tg3.c:v3.133 (Jul 29, 2013)
[26914.544289] tg3 0000:09:00.0: irq 46 for MSI/MSI-X
[26914.547560] tg3 0000:09:00.0 eth0: Tigon3 [partno(BCM95755m) rev a002] (PCI Express) MAC address 00:1c:23:41:6d:eb
[26914.547565] tg3 0000:09:00.0 eth0: attached PHY is 5755 (10/100/1000Base-T Ethernet) (WireSpeed[1], EEE[0])
[26914.547568] tg3 0000:09:00.0 eth0: RXcsums[1] LinkChgREG[0] MIirq[0] ASF[0] TSOcap[1]
[26914.547571] tg3 0000:09:00.0 eth0: dma_rwctrl[76180000] dma_mask[64-bit]
[26914.579784] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
``` 
We see at the beginning the loading of the whole system, the detection of the hard disk, the cdrom, the map of sound, the card nvidia, all the information of the detection and the loadings of module nuclei are present. We also see at the end that the tg3 module was loaded several times at the system level, this represents my demonstration of loading and unloading done earlier. I would like to pay attention to line 69 we find the error of the parameter potato that I had transmitted to the module, we find that the actual parameter was ignored. When adding a USB data key you will also find that the kernel returns information with the partitions present and the file name in / dev that was created as well as the partitions associated with it.

## Graphics Application  
Hardinfo

